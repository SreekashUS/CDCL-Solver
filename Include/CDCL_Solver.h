#ifndef CDCL_SOLVER_H
#define CDCL_SOLVER_H

//Includes
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <iostream>
#include <string>
#include <vector>
#include <fstream>

#include <random>
#include <iterator>

/*
Types:
Formula type- 	(Contains clauses)
Solver type -	(Contains solver)
*/

//Override
static std::ostream& operator << (std::ostream& os, const std::vector<int>& v) 
{
    os << "[";
    for (unsigned int i=0;i<v.size();i++)
    {
        os << " " << v[i];
    }
    os << "]";
    return os;
}

//Modulus
static int mod(int x)
{
	return (x>0)? x:-x;
}

//Random picker
template<typename Iter, typename RandomGenerator>
Iter select_randomly(Iter start, Iter end, RandomGenerator& g) 
{
    std::uniform_int_distribution<> dis(0, std::distance(start, end) - 1);
    std::advance(start, dis(g));
    return start;
}

template<typename Iter>
Iter select_randomly(Iter start, Iter end) 
{
    static std::random_device rd;
    static std::mt19937 gen(rd());
    return select_randomly(start, end, gen);
}


enum Sol_States
{
	SAT,			//Satisfied
	UNSAT,			//Unsatisfied
	CONT,			//Continue
	CONFL 			//Conflict occured
};

enum Sol_Mode
{
	DEBUG,			//Debug mode(print necessary information to the console)
	RUN 			//Run the solver as it is and give result to the SAT problem
};

class CDCLSolver 
{
private:
	//Current decision level
	int Current_DL;
	//Backprop decision level
	int Backprop_DL;
	//Clause limit (Clauses generated by the CDCL algorithm)
	int clause_limit;

	//Origimal formula for comparison
	std::vector<std::vector<int>> orig_formula;
	//Current formula
	std::vector<std::vector<int>> curr_formula;

	//literal assignments and level
	std::vector<int> literals;
	//literal indexes
	std::vector<int> lis;

	//frequency of literals
	std::vector<int> liter_freq;
	//polarity of literals
	std::vector<int> liter_pol;

	//Original freq list used if reset
	std::vector<int> orig_lit_freq;

	//Conflict antecedent
	int confl_ante;
	//assigned literals
	unsigned int assigned_lits;
	//literal count
	unsigned int literal_count;
	//clause count
	unsigned int clause_count;

	//literal antecedent
	std::vector<int> literal_ante;
	//count of assigned literals
	int assigned;
	//unsatisfied
	bool already_unsat;

	//Clauses generated by CDCL
	std::vector<std::vector<int>> Clauses_gen;

	//Resolvent clause
	std::vector<int> Resolvent_Clause;

	/*
	Find unit literal and apply value in DL and literal tables
	Loop until unit literals are done or if conflict is implied
	Keep track of implied literals and clauses
	(i.e occuring after the first unit literal iteration) which
	later can be used for conflict resolution and backtracking
	*/
	int UnitProp();

	/*
	Perform conflict analysis
	*/
	int Conflict();

	/*
	Resolves the list of clauses generated for resolvent
	*/
	std::vector<int> Resolve(std::vector<int> clause,int resolver_lit);

	/*
	Based on the current resolved clause backtrack based on literals
	assigned at current decision level and unassign literals at lower
	levels and add clause to the main clause
	*/
	int BackTrack();

	/*
	Pick a literal for the algorithm, stop picking literals if a 
	certain clause limit is reached and restart the algorithm with new
	random sequence of literal selection
	*/
	int PickLiteral();

	/*
	Assign a literal at current decision level with antecedent
	*/
	void AssignLit(int literal,int DL,int ante);

	/*
	Unassign literal from it's DL and value;
	*/
	void UnassignLit(int literal);

	/*
	All literals Assigned?
	*/
	bool All_Assigned();

	//For showing results
	bool Solver_Status;

public:

	//Ctor
	//Pass clause limit and Formula F for solving
	CDCLSolver();
	//Dtor
	virtual ~CDCLSolver();

	/*
	Initialize the solver with needed clause limit and 
	The formula provided to check SAT
	*/
	void Init(int clause_limit);

	/*
	Solving part of the solver
	*/
	int Solve();

	/*
	Debug part of the solver
	*/
	void ShowStages();

	/*
	Load from file
	*/
	void Load(const char* filename);

	//Read from command prompt
	void Read();

	//Show result
	void ShowResult();
};


#endif //CDCL_SOLVER_H